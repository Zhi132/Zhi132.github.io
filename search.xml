<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于本站]]></title>
    <url>%2F2019%2F06%2F21%2Ftop%2F</url>
    <content type="text"><![CDATA[​ 博主之前是在CSDN与博客园上写博客的。但是慢慢地CSDN上广告突出……博客园也很少用，就自己上网学习，搭hexo博客。 CSDN 博客园]]></content>
      <tags>
        <tag>Info</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3]]></title>
    <url>%2F2019%2F06%2F20%2Fcss3%2F</url>
    <content type="text"><![CDATA[二、选择器孟坤工具箱 层次选择器 后代选择器 123body p&#123; background:red;&#125; 子选择器 123body&gt;p&#123; background:pink;&#125; 相邻选择器 123.active+p&#123; backgroung:green;&#125; 通用兄弟选择器(同一层) 123.active~p&#123; background:yellow;&#125; 结构伪类选择器 选择第一个子元素 123ul li:first-child&#123; background:red;&#125; 选择最后一个子元素 123ul li:last-child&#123; background:green;&#125; 选择第n个子元素(父元素) 123p:nth-child(2)&#123; background:yellow;&#125; 选择第n个元素(同级) 123p:nth-of-type(2)&#123; background:blue;&#125; 属性选择器 E[attr]：选择匹配具有属性attr的E元素 a[id=first]：具有id属性且匹配first a[class=”links”]：class=links的会改变 a[class*=”links”]：class中包含links的会改变 a[href^=http]：以http开头元素 a[href$=png]：以png结尾的元素 三、CSS美化页面 盒子模型-]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出-MySQL]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-MySQL%2F</url>
    <content type="text"><![CDATA[一、SQL基础1、SQL分类 DDL：数据定义语句 创建数据库 123456create database test1## 数据库中已有的1. information_schema:存储系统中的一些数据库对象信息2. cluster:存储了系统的集群信息3. mysql: 存储了系统的用户权限信息。4. test: 系统自动创建的测试数据库。 删除数据库 1drop database test1 创建表 12345678create table **();查看表的定义DESC **查看创建表的SQL语句show create table ** \G;在这里我们可以看到ENGINE（存储引擎）和CHARSET（字符集信息） 删除表 1drop table emp 修改表 12345678910111213141516171819## 修改表类型alter table emp modify ename varchar(20)## 增加表字段alter table emp add column age int(3)## 删除表字段alter table emp drop column age;## 字段改名alter table emp change age age1 int(4);## 修改字段排列顺序(可选项 first|after)alter table emp add birth data after ename; &gt; 修改字段age，将它放在最前边 alter table emp modify age int(3) first;## 更改表名alter table emp rename emp1; DML：数据操作语句 ​ 是对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询。 插入记录 12345## 插入语句insert into emp(1,2) values(1,2)## 一次性插入多条语句insert into emp(1,2) values(1,2),(2,3) 更新记录 1234## 更新update emp set 1=1 wherh ename='lisi'## 同时更新两个表与这个情况类似 删除记录 12## 删除delete from emp where ename='dony' 查询记录 12345678910111213141516171819202122232425262728293031323334353637383940## 查询select * from emp## 查询不重复的记录select distinct deptno from emp;## 条件查询(=、&gt;、&lt;、&gt;=、&lt;=、!=)select * from emp where 1=1 and 2=2;## 排序和限制select * from emp order by sal;desc----&gt;降序 asc------&gt;升序## 分页查询select * from emp order by sal limit 1,3 -----&gt;第一个参数为起始偏移量，第二个为行数## 聚合select [f1,f2,f3...]fun_name------&gt;聚合函数 sun，count，max，minfrom tablename[WHERE where_contition] -----&gt;条年间查询[GROUP BY field1,field2 -----&gt;分类聚合字段[WITH ROLLUP]] -----&gt;表名是否对分类聚合进行汇总[HAVING where_contition]-----&gt;对分类后的结果再进行条件的过滤## 连接1、内连接 仅选出两张表中互相匹配的记录 fx：查询所有雇员的名字和所在的部门名称 select ename,deptname from emp,dept where emp.deptno=dept.deptno;2、外连接 左连接：包含所有左边表中的记录甚至是右边表中没有和它匹配的记录。 右连接：包含所有右边表中的记录甚至是左边表中没有和它匹配的记录。3、子查询（条件是另一select语句的结果） select * fomr emp where 1 in(select 1 from dept); 如果查询条件唯一，可以使用=代替in4、记录联合 UNION: 将UNION ALL后的结果进行一次DISTINCT UNION ALL 把结果集直接合并在一起 DCL：数据控制语句—–管理系统中的对象权限时使用 2、MySQL数据类型 整数类型 字节 最小值 最大值 TINYINT 1 有符号-128无符号 0 有符号 127无符号 255 SMALLINT 2 有符号-32768无符号 0 有符号32767无符号 65535 MEDIUMINT 3 有符号-8388608无符号 0 有符号8388607无符号 1677215 INT,INTEGER 4 有符号-2147483648无符号 0 有符号2147483647无符号 4294967295 BIGINT 8 有符号-9223372036854775808无符号 0 有符号9223372036854775807无符号 18446744073709551615 浮点数类型 字节 最小值 最大值 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 位类型 字节 最小值 最大值 BIT 1~8 BIT(1) BIT(64) 二、MySQL开发篇1、表类型的选择]]></content>
      <categories>
        <category>MySQL学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解]]></title>
    <url>%2F2019%2F06%2F19%2FSpring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[核心容器 Spring的核心jar包​ 一、spring-context—–maven注入 ##### 没有注解之前，使用配置方式​ 使用注解 @Configuration 配置类 @Bean给容器一注册一个Bean；类型为方绘制的类型，id默认为id 可以给Bean添加value值 12ApplicationContextnew a = AnnotationConfigApplicationContext(配置类.class);Person p = a.getBean(Person.class); 包扫描&lt;context:componet-scan class=””&gt; 只要标注了@Controller @Service @Repository @Component 自动扫描 包扫描过滤 在其下边继续写&lt;context:include合作者exclude 另一种方法可以在配置类上边加注解 @ComponentScan(value=””)—-和上边包扫描效果一样会自动扫描 12345指定要扫描的包@ComponentScan(value="",excludeFilters = &#123; @Filter(type=FilterType.ANNOTATION,classes= &#123;Controller.class,Service,class&#125;) &#125;)如果要使用只扫描--我们需要把useDefaultFilters = false 默认扫描关闭 在其中我们还可以使用ComponentScans来扫描多个 value是数组 常用规则（扫描方式） FilterType.* 1、ANNOTATION 按照注解 2、ASSIGNABLE_TYPE 按照给定的类型 3、ASPECTJ ASPECTJ表达式 4、REGEX 正则表达式 5、CUSTOM 自定义规则 需要实现TypeFilter接口 修改Scope（调整组件作用域） prototype 多实例的 singletion 单实例的 懒加载@Lazy 单实例Bean：默认在启动的时候创建对象 第一次使用Bean的时候再创建对象—–懒加载 按照条件注册bean @Conditional: 按照一定的条件进行判断，满足条件给容器中注册bean @Conditional(Condition数组—》类.class) 实现的类需要实现Conditional接口，来为后续的判断提供条件]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础]]></title>
    <url>%2F2019%2F06%2F18%2FJavaSE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaSE面试要点以及知识概要 1、面向对象的特征有哪些方面 抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 2、基本数据类型​ 基本数据类型包括 byte、int、char、long、float、double、boolean、short​ java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 3、super和this的区别​ super代表父类对象，this代表当前类对象 4、==和equals的区别== 基本类型：比较值是否相同 引用类型：比较引用是否相同 代码示例 1234567String x = "string";String y = "string";String z = new String("string");system.out.println(x==y); //true 比较引用system.out.println(x==z); //false 比较引用system.out.println(x.equals(y)); //true 比较值system.out.println(x.equals(z)); //true 比较值 equals ​ equals本质上是==，不过String和Integer等重写了equals方法，变为了值比较 5、两个对象的hashcode相同，equals相同么​ hashcode得到的是哈希值相同，然而哈希值相同，并不能得到键值对相同。 6、final在Java中的作用 final修饰的类交最终类，改类不能被继承 final修饰的方法不能被重写 final修饰的变量交常量，常量必须初始化，初始化之后值不能被修改 7、操作字符串的类String声明的是不可变的对象，每次操作都会生成新的String对象。 StringBuffer、StringBuilder可以在原有对象的基础上进行操作 String和StringBuilder的区别 1. StringBuffer是线程安全的 StringBuilder是非线程安全的 2.StringBuilder性能比StringBuffer高 3.单线程可以使用StringBulider 多项成使用StringBuffer 8、String s=”i” 与 String s1=new String(“asd”)的区别​ 第一种是分配到常量池中，第二种是分配到堆内存中。 9、抽象类必须要有抽象方法么？​ 不需要，抽象类不一定非要有抽象方法。 我们来具体分析一下抽象与接口 抽象类是什么？（抽象类只能作为父类被继承，避免子类的随意性） 抽象方法只做声明，而不包含实现，可以看成是没有实现体的虚方法 抽象类不能被实例化 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类 具体派生类必须覆盖基类的抽象方法 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们 接口是什么？ 接口不能被实例化 接口只能包含方法声明 接口的成员包括方法、属性、索引器、事件 接口中不能包含常量、字段(域)、构造函数、析构函数(Java存在自动回收机制，一般用不到析构函数)、静态成员 接口和抽象类的区别 重要 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含静态方法，接口中不能包含静态方法 一个类可以实现多个接口，但只能继承一个抽象类。 接口可以被多重实现，抽象类只能被单一继承 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法 接口和抽象类的相同点 都可以被继承 都不能被实例化 都可以包含方法声明 派生类必须实现未实现的方法 10、&amp;和&amp;&amp;的区别？ &amp;运算符有两种用法： 按位与； 逻辑与。 &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实训---html]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%AE%9E%E8%AE%AD-html%2F</url>
    <content type="text"><![CDATA[HTML W3C标准1. 结构化标准语言(HTML,XHML) 2. 表现标准语言(CSS) 3. 行为标准(DOM)meta设置1234567891011121314151617181920&lt;meta charset="UTF-8"&gt;&lt;title&gt;我的第一个网页&lt;/title&gt;&lt;!--设置过期--&gt;&lt;meta http-equiv="Expires" content="0"&gt;&lt;!--跳转页面--&gt;&lt;meta http-equiv="refresh" content="2:http://www.baidu.com"&gt;&lt;!----&gt;&lt;meta http-equiv="Pragma" content="No-cach"&gt;&lt;!--无法被其他网页嵌套--&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!--网页特效--&gt;&lt;meta http-equiv="Page-Exit"&gt;&lt;!--搜索关键字--&gt;&lt;meta name="Keywords" lang="EN" content="中北大学"&gt;&lt;!--设置网页简介--&gt;&lt;meta name="description" content="中北大学"&gt;&lt;!--设置网址作者--&gt;&lt;meta name="Author" content="银尘"&gt;&lt;!--设置网站的版本--&gt;&lt;meta name="Copyright" content="本页版权归银尘所有"&gt; 页面布局分析H5结构元素 方法名 作用位置 header 头部 nav 头部 aside 侧面栏 section 主题部分 article 主题部分 footer 尾部 框架 frameset—-现在不经常使用了 iframe—基本都使用这个（灵活）]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器知识点]]></title>
    <url>%2F2019%2F06%2F18%2FJava%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Java容器与设计模式解释 单例模式静态初始化（饿汉式）双重检查（懒汉式） 用到的时候才会建立，不用则不会建立 要考虑多个线程的并发问题 通过lock和synchronized双重检查 保证只有一个线程运行 内存可见性 volatile 修饰 单例注册表常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 反射 静态代理:编译时创建好的 源代码中编写的类 动态代理:在JVM 责任链模式：Netty消息处理的方式 适配器模式：SLF4J如何支持Log4J — 接口 观察者模式（一个对象的某个事件触发某些行为）：GRPC是如何支持流式请求的 构造者模式（多个复杂的属性）：PB序列化中的Builder Java语言特性知识详解==HashMap== 数组加链表的实现方式 容量大小是2的幂次方 可以利用按位与操作，计算余数 并发读写的风险（参考源码） 死循环问题 HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） 工作原理 HashMap 在 Map.Entry 静态内部类实现中存储键值对，使用哈希算法。在 put 和 get 方法中，使用 hashCode() 和 equals() 方法。 调用 put 方法时，使用键值对中的 Key hashCode() 和哈希算法找出存储键值对索引。键值对 Entry 存储在 LinkedList 中，如果存在 Entry，使用 equals() 方法来检查 Key 是否已经存在：如果存在，则覆盖 value；如果不存在，会创建一个新的 Entry 然后保存。 调用 get 方法时，HashMap 使用键值 Key hashCode() 来找到数组中的索引，然后使用 equals() 方法找出正确的 Entry，返回 Entry 中的 Value。 ==ConcurrentHashMap== ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 并发控制与分段锁的思想 1.8的CAS自旋锁 红黑树的启动条件 TREEIFY THRESHOLD==8 阈值超过8 小于6就转回链表 具体的get方法 - 当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。 hash源码 1234567891011static final int hash(Object key) &#123; if (key == null)&#123; return 0; &#125; int h; h = key.hashCode()；返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 //其中n是数组的长度，即Map的数组部分初始化长度 return (n-1)&amp;(h ^ (h &gt;&gt;&gt; 16)); &#125; 源码分析(个人理解n初始化数组长度为16) 高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）(n·1) &amp; hash = -&gt; 得到下标 为什么一直使用红黑树，不使用二叉树呢? 二叉树在使用过程中可能会变成一条线性结构，这就相当于链表结构了，查找速度会很慢。红黑树可以在插入数据时进行左旋，右旋、变色这些操作来保持平衡。所以，我们在长度大于8的时候，我们会使用红黑树，长度小于8的时候就没有必要用了，反而会更慢。 说说你对红黑树的见解 应该不会手撕。。。。 每个节点非红即黑 根节点总是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 每个叶子节点都是黑色的空节点（NIL节点） 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 解决hash碰撞的方法 开放定址法 当冲突发生时，使用某种探查技术在散列表中形成一个探查（测）序列。沿此序列逐个单元地查找，直到找到给定的地址。按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。 如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？ HashMap 默认的负载因子大小为0.75。也就是说，当一个 Map 填满了75%的 bucket 时候，和其它集合类一样（如 ArrayList 等），将会创建原来 HashMap 大小的两倍的 bucket 数组来重新调整 Map 大小，并将原来的对象放入新的 bucket 数组中。这个过程叫作 rehashing。只有两个可能的位置:一个是原下标的位置，另一种是在下标为 &lt;原下标+原容量&gt; 的位置。 什么情况会引起多线程 在调整HashMap大小的时候，如果两个线程同时调整HashMap大小的话，可能会发生条件竞争。然后就—-&gt;死循环了。。。 为什么多线程会死循环。怎么发生的？ HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。这时候， HashMap 需要扩展它的长度，也就是进行Resize。扩容：创建一个新的 Entry 空数组，长度是原数组的2倍rehash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 详解 HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 容器的区别==HashTable与HashTable== HashTable 数组+链式存储 默认容量：11 put操作：首先进行索引计算 （key.hashCode() &amp; 0x7FFFFFFF）% table.length；若在链表中找到了，则替换旧值，若未找到则继续；当总元素个数超过 容量 * 加载因子 时，扩容为原来 2 倍并重新散列；将新元素加到链表头部 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全 HashMap和HashTable的区别 默认容量不同，扩容不同 线程安全性： HashTable安全 效率不同： HashTable要慢 加锁了 可以使用 CocurrentHashMap 来代替 Hashtable 吗？ 我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁 ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性 它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map ==Collection详解== Set TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序 List ArrayList 基于动态数组实现，支持随机访问。 Vector 和 ArrayList 类似，但它是线程安全的。 LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList 可以用来实现双向队列 PriorityQueue 基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 5. ArrayList和Vector的区别Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; synList = Collections.synchronizedList(list);6.ArrayList和LinkedList比较ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。7.LinkedHashMap继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 8.为什么要实现序列化实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果 你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布 式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
