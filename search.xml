<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F06%2F27%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式 对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 在秒杀系统中也使用了观察者模式。 大白话：一个人发送消息，其他人都可以接受到 观察者模式的优点： **观察者和被观察者是抽象耦合的 ** **观察者模式实现了动态联动 ** 观察者模式支持广播通信 观察者模式的缺点： **如一个主题被大量观察者注册，则通知所有观察者会花费较高代价 ** 如果某些观察者的响应方法被阻塞，整个通知过程即被阻塞，其它观察者不能及时被通知 虽然观察者模式提取出了抽象类，让类与类之间不互相依赖，共同依赖于抽象接口，这符合依赖倒转原则，但他们仍然依赖着抽象接口，而且有些时候不能提取出抽象的观察者（比如引用jar包）。]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式详解]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[单例模式 简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。getInstance()的返回值是一个对象的引用，并不是一个新的实例,所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧 下边书写一个Singleton来表示创建单例 12345678910111213141516171819202122232425262728package com.singletonpattern;/** * 简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new， * 因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。 * getInstance()的返回值是一个对象的引用，并不是一个新的实例， * 所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧 */public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton singleton; /* 私有构造方法，防止被实例化 */ private Singleton()&#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance()&#123; if(singleton == null)&#123; //1、读取 singleton = new Singleton(); //2、实例化 &#125; return singleton; &#125;&#125; 创建多线程来访问 123456789101112131415161718package com.singletonpattern;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MultiThreadMain &#123; public static void main(String[] args) &#123; ExecutorService threadPool = Executors.newFixedThreadPool(20); for(int i = 0; i &lt; 20; i++)&#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+":"+Singleton.getInstance()); &#125; &#125;); &#125; &#125;&#125; 我们可以看一下运行结果 我们可以看到在这个结果中出现了一个com.singletonpattern.Singleton@703b5，说明返回的不是一个实例。这就谈到了我们的线程安全问题。 为什么会出现线程安全问题呢？ ​ 如果此时有两个线程，线程A执行到1处，读取了instance为null，然后cpu就被线程B抢去了，此时，线程A还没有对instance进行实例化。 ​ 因此，线程B读取instance时仍然为null，于是，它对instance进行实例化了。然后，cpu就被线程A抢去了。此时，线程A由于已经读取了instance的值并且认为它为null，所以， ​ 再次对instance进行实例化。所以，线程A和线程B返回的不是同一个实例。 如何去解决呢？ 1、在方法前边加synchronized修饰。这样肯定不会再有线程安全问题。 123456789101112131415161718public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton singleton; /* 私有构造方法，防止被实例化 */ private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 这种方法会很慢 ​ 这种解决方式，假如有100个线程同时执行，那么，每次去执行getInstance方法时都要先获得锁再去执行方法体，如果没有锁，就要等待，耗时长，感觉像是变成了串行处理。因此，尝试其他更好的处理方式。 2、加同步代码块，减少锁的颗粒大小。 ​ 我们发现，只有第一次instance为null的时候，才去创建实例，而判断instance是否为null是读的操作，不可能存在线程安全问题，因此，我们只需要对创建实例的代码进行同步代码块的处理，也就是所谓的对可能出现线程安全的代码进行同步代码块的处理。 123456789101112131415161718192021public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton singleton; /* 私有构造方法，防止被实例化 */ private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; synchronized (Singleton.class)&#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 这样解决之后还会出现问题么？答案是肯定的。 ​ 如果此时有两个线程，线程A执行到1处，读取了instance为null，然后cpu就被线程B抢去了，此时，线程A还没有对instance进行实例化。 ​ 因此，线程B读取instance时仍然为null，于是，它对instance进行实例化了。然后，cpu就被线程A抢去了。此时，线程A由于已经读取了instance的值并且认为它为null，所以， ​ 再次对instance进行实例化。所以，线程A和线程B返回的不是同一个实例。 与刚开始分析的问题是一致的 3、在上边问题出现之后我们还可以怎么样去解决这个问题呢？ ​ 我们可以想到，如果在同步构造块之前与之后我们都进行null判断，那么我们是不是可以缓解线程安全问题。 答案是：可以的--------&gt;(双重检查加锁)]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F06%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[👉💭计算机网络 参考链接 计算机网络基础知识 计算机网络 1、计算机网络体系结构 OSI七层模型 TCP/IP概念层模型 功能 TCP/IP协议族 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，DNS 表示层 应用层 数据格式化，代码转换，数据加密 没有协议 会话层 解除或建立与别的接点的联系 没有协议 传输层 传输层 提供端对端的接口 TCP、UDP 网络层 网络层 为数据包选择路由(数据传输服务) IP，ICMP、RIP、OSPF 数据链路层 链路层 传输有地址的帧以及错误检验功能 SLIP、CSLIP 物理层 以二进制数据形式在物理媒体上传输数据 ISO02110 传输层的两种协议 ​ 1、传输控制协议TCP：提供面向连接、可靠的数据传输服务、数据单位为报文段。 ​ 2、用户数据报协议UDP：提供无连接、尽最大努力的数据传输服务、数据单位为用户数据报。 ​ 3、TCP主要提供完整性服务，UDP主要提供及时性服务。 TCP/IP ​ 1、它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 ​ 2、TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 ​ 3、TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占据举足轻重的地位。 2、物理层 2.1通信方式 根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 3、数据链路层 3.1基本问题 1、封装成帧 ​ 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2、透明传输 ​ 透明表示一个实际存在的事物看起来好像不存在一样。 fx ​ 如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3、差错检验 ​ 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错 3.2信道分类 1、 广播信道 ​ 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 2、点对点信道 ​ 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 3.3信道复用技术 1、频分复用 ​ 频分复用的所有主机在相同的时间占用不同的频率带宽资源。(利用率不高) 2、时分复用 ​ 时分复用的所有主机在不同的时间占用相同的频率带宽资源。(利用率不高) 3、统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 4、波分复用 ​ 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 5、码分复用 ​ 为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 s 和 t有 3.4 CSMA/CD 协议 CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 3.5 PPP协议 互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 3.6 MAC地址 MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 3.7局域网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 3.8以太网 以太网是一种星型拓扑结构局域网。 3.9交换机 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 3.10虚拟局域网 虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息 4、网络层 4.1概念 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） 4.1.1 IP分类的历史 1. 分类 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 5、传输层 5.1TCP与UDP的区别 TCP是面向连接的，UDP是无连接的； TCP是可靠的，UDP是不可靠的； TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式； TCP是面向字节流的，UDP是面向报文的； TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信； TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大； 5.2三次握手👉建立TCP连接 ​ 所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： 5.2.1详细解释 在下边介绍中使用到了标志位，这里也介绍一下 TCP标志位-------&gt;6种 SYN---------------------建立联机（同步序号） ACK---------------------确认 PSH---------------------传送 FIN---------------------结束 RST---------------------重置 URG---------------------紧急 Sequence number-----------------顺序号码) Acknowledge number-------------确认号码 前提：A为客户端，B为服务端，B应该处于监听状态，等待客户需求。 第一步：A-&gt;B发起报文请求，SYN=1，ACK=0，初始序号为x. 第二步：B收到报文请求之后，如果同意建立连接，则会向A发送连接确认报文，SYN=1，ACK=1，确认号为x+1， 同时也需要发送一个初始的序号y。 第三步：A收到B的确认之后，还需要继续向B发出确认，确认号为y+1，序号为x+1.B收到之后，与A建立连接。 5.2.2为什么要进行三次握手 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 5.2.3为什么不进行一次握手或者两次握手 ​ 为什么不能一次握手很容易理解，TCP是面向连接的，一次握手肯定建立不了连接，一条信息发出去连个回信都没有怎么连接？ ​ 所以问题在为什么不能两次握手，这个问题也很容易网上说的也不少，假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，在发送一个SYN，B也成功收到，然后A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费 ​ 那三次握手为什么可以？两次握手的问题在于服务器端不知道一个SYN是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向Server写数据，Server端将以RST包响应，方能感知到Server的错误。 实现机制（上边已经阐述） 第一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放 第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK 第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST 5.3四次挥手👉断开连接 ​ 四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示： 5.3.1详细解释 第一步：A发送释放报文，FIN为1。 第二步：B结束之后发出确认，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据。 第三步：当B不再需要连接时，发送连接释放报文，FIN=1. 第四步：A收到后发送确认，进入TIME-WAIT状态，等待2MSL后释放连接。B收到A的确认后释放连接。 5.3.2为什么要进行四次挥手，为什么是四次而不是三次呢？ 为了断开TCP连接 &gt; 前两次挥手：结束一个方向的连接 &gt; &gt; 后两次挥手：结束另一个方向的连接 下边引入一张图片来深入理解一下 5.3.3为什么有TIME_WAIT？ 客户端在接受服务器的FIN之后，并不是直接进入CLOSED状态，而是需要等待2MS，有以下两个原因 ​ 1、为了确保最后一个确认报文能够送达 ​ 2、等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 5.4TCP可靠传输 ​ TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 5.5TCP滑动窗口 5.5.1作用 ​ 1、提供TCP的可靠性 ​ 2、提供TCP的流控特性 5.5.2TCP窗口机制 TCP的窗口机制有两种，一种是固定窗口大小，另一种是滑动窗口。数据在传输时,TCP会对所有数据进行编号，发送方在发送过程中始终保持着一个窗口，只有落在发送窗口内的数据帧才允许被发送；同时接受方也始终保持着一个接收窗口，只有落在窗口内的数据才会被接收。这样通过改变发送窗口和接收窗口的大小就可以实现流量控制。 5.5.3TCP窗口大小 当窗口过大时，会导致不必要的数据来拥塞我们的链路，但是窗口太小时，会造成很大的延时，比如为1时，发送方没发送一个数据，接受方就会返回一个ack报文，在发送方未接收到接受方的确认报文ack之前不会进行下一次发送。当链路变好了或者变差了这个窗口还会发生变化，并不是第一次协商好了以后就永远不变了。 5.5.4窗口滑动协议 是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待接收确认报文前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务管理]]></title>
    <url>%2F2019%2F06%2F25%2FSpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[👉🙋Spring事务管理 1、Spring的数据库编程 1.1Spring JDBC的配置 123&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;!--添加数据库连接驱动以及URL，USER，PASS--&gt;&lt;/bean&gt; 1.2Spring JdbcTemplate的常用方法 int update(String sql,Object args[]);```对数据表进行增加，修改，删除12345678910111213141516171819```public List&lt;T&gt; query(Strinbg sql,RowMapper&lt;T&gt; rowMapper,Object args[]);```查询操作，并映射到自定义类中----》rowMapper## 2、编程式事务管理&gt; ​ 概念：在代码中调用beginTransaction、commit、rollback等与事务处理相关的方法。### 2.1基于底层API的编程式事务管理&gt; ​ 基于底层API的编程式事务管理，就是根据**PlatformTransactionManager**、**TransactionDefinition** 和 **TransactionStatus** 三个核心接口，通过编程的方式来进行事务处理。#### 2.1.1给数据源配置事务管理器```xml&lt;!—为数据源添加事务管理器 --&gt;&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 2.1.2创建数据访问类 2.1.3创建测试类 2.2、基于TransactionTemplate的编程式事务管理 ​ TransactionTemplate的execute()方法有一个TransactionCallback接口类型的参数，该接口中定义了一个doInTransaction()方法，通常以匿名内部类的方式实现TransactionCallback 接口，并在其doInTransaction()方法中书写业务逻辑代码。这里可以使用默认的事务提交和回滚规则，在业务代码中不需要显式调用任何事务处理的API。doInTransaction()方法有一个TransactionStatus类型的参数，可以在方法的任何位置调用该参数的setRollbackOnly()方法将事务标识为回滚，以执行事务回滚。 3、声明式事务管理 ​ Spring的声明式事务管理是通过AOP技术实现的事务管理，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 3.1基于XML方式的声明式事务管理 3.1.1导入jar包 3.1.2创建Dao层 12345package com.statement.dao;public interface TestDao &#123; public int save(String sql, Object param[]); public int delete(String sql, Object param[]);&#125; TestDaoImpl实现 1234567891011121314151617package com.statement.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repository("TestDao")public class TestDaoImpl implements TestDao&#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int save(String sql, Object[] param) &#123; return jdbcTemplate.update(sql,param); &#125; @Override public int delete(String sql, Object[] param) &#123; return jdbcTemplate.update(sql,param); &#125;&#125; 3.1.3创建Service层 3.1.4创建Controller层 3.1.5创建配置文件—重要 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 指定需要扫描的包（包括子包），使注解生效 --&gt; &lt;context:component-scan base-package="com.statement"/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;!-- MySQL数据库驱动 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;!-- 连接数据库的URL --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springtest?characterEncoding=utf8"/&gt; &lt;!-- 连接数据库的用户名 --&gt; &lt;property name="username" value="root"/&gt; &lt;!-- 连接数据库的密码 --&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- 配置JDBC模板 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 为数据源添加事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 编写通知声明事务 --&gt; &lt;tx:advice id="myAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;!-- *表示任意方法 --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 编写AOP，让Spring自动对目标对象生成代理，需要使用AspectJ的表达式 --&gt; &lt;aop:config&gt; &lt;!-- 定义切入点 --&gt; &lt;aop:pointcut expression="execution(* com.statement.service.*.*())" id="txPointCut"/&gt; &lt;!-- 切面：将切入点与通知关联 --&gt; &lt;aop:advisor advice-ref="myAdvice" pointcut-ref="txPointCut"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 3.2基于@Transactional注解的声明式事务管理 3.2.1创建配置文件 1234567&lt;!-- 为数据源添加事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 为事务管理器注册注解驱动 --&gt; &lt;tx:annotation-driven transaction-manager="txManager" /&gt; 3.2.2为Service添加@Transactional注解 12345@Service("testService")@Transactional//加上注解@Transactional,就可以指定这个类需要受Spring的事务管理//注意@Transactional只能针对public属性范围内的方法添加-----需要注意public class TestServiceImpl implements TestService&#123; 3.3如何在事务处理中捕获异常 3.3.1声明式事务处理的流程 ​ 1、Spring根据配置完成事务定义，设置事务属性 ​ 2、执行开发者的逻辑代码 ​ 3、如果开发者的代码产生异常（主键重复）并且满足回滚的配置文件，则事务回滚，否则事务提交 ​ 4、事务资源释放 3.3.2在基于XML的方式的声明式事务管理中捕获异常 （1）为xml配置文件中添加 roolback-for=&quot;&quot;。 （2）在catch语句中添加throw new RuntimeException(); 3.3.3在基于注解的声明式事务管理中捕获异常 （1）@Transactional改为@Transactional(rollbackFor={Exception.class}) （2）在catch语句中添加throw new RuntimeException(); 在实际项目中经常在catch语句中添加TransactionAspectSupport.currentTransactionStatus.setRollbackOnly();]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAop]]></title>
    <url>%2F2019%2F06%2F25%2FSpringAop%2F</url>
    <content type="text"><![CDATA[👉SpringAop详解 一、前言 ​ 在以前的学习中，只学习了如何入使用AOP，并没有真正去了解Spring的一些核心概念。这几天通过上网搜索。看到了一篇博主的文章。特此摘抄：大佬博客 AOP AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为&quot;横切&quot;的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为&quot;Aspect&quot;，即切面。所谓&quot;切面&quot;，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用&quot;横切&quot;技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP核心概念 1、横切关注点 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2、切面（aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象 3、连接点（joinpoint） 被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 4、切入点（pointcut） 对连接点进行拦截的定义 5、通知（advice） 所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类 6、目标对象 代理的目标对象 7、织入（weave） 将切面应用到目标对象并导致代理对象创建的过程 8、引入（introduction） 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 Spring对AOP的支持 Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为： 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分： 1、定义普通业务组件 2、定义切入点，一个切入点可能横切多个业务组件 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作 所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。 下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展： 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;/beans&gt; 基于Spring的AOP简单实现 注意一下，在讲解之前，说明一点：使用Spring AOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包： 1、aopalliance.jar 2、aspectjweaver.jar 开始讲解用Spring AOP的XML实现方式，先定义一个接口： 12345public interface HelloWorld&#123; void printHelloWorld(); void doPrint();&#125; 定义两个接口实现类： 12345678910111213public class HelloWorldImpl1 implements HelloWorld&#123; public void printHelloWorld() &#123; System.out.println("Enter HelloWorldImpl1.printHelloWorld()"); &#125; public void doPrint() &#123; System.out.println("Enter HelloWorldImpl1.doPrint()"); return ; &#125;&#125; 12345678910111213public class HelloWorldImpl2 implements HelloWorld&#123; public void printHelloWorld() &#123; System.out.println("Enter HelloWorldImpl2.printHelloWorld()"); &#125; public void doPrint() &#123; System.out.println("Enter HelloWorldImpl2.doPrint()"); return ; &#125;&#125; 横切关注点，这里是打印时间： 1234567public class TimeHandler&#123; public void printTime() &#123; System.out.println("CurrentTime = " + System.currentTimeMillis()); &#125;&#125; 有这三个类就可以实现一个简单的Spring AOP了，看一下aop.xml的配置： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean id="helloWorldImpl1" class="com.xrq.aop.HelloWorldImpl1" /&gt; &lt;bean id="helloWorldImpl2" class="com.xrq.aop.HelloWorldImpl2" /&gt; &lt;bean id="timeHandler" class="com.xrq.aop.TimeHandler" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="time" ref="timeHandler"&gt; &lt;aop:pointcut id="addAllMethod" expression="execution(* com.xrq.aop.HelloWorld.*(..))" /&gt; &lt;aop:before method="printTime" pointcut-ref="addAllMethod" /&gt; &lt;aop:after method="printTime" pointcut-ref="addAllMethod" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 写一个main函数调用一下： 12345678910111213141516public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("aop.xml"); HelloWorld hw1 = (HelloWorld)ctx.getBean("helloWorldImpl1"); HelloWorld hw2 = (HelloWorld)ctx.getBean("helloWorldImpl2"); hw1.printHelloWorld(); System.out.println(); hw1.doPrint(); System.out.println(); hw2.printHelloWorld(); System.out.println(); hw2.doPrint();&#125; 运行结果为： 123456789101112131415CurrentTime = 1446129611993Enter HelloWorldImpl1.printHelloWorld()CurrentTime = 1446129611993CurrentTime = 1446129611994Enter HelloWorldImpl1.doPrint()CurrentTime = 1446129611994CurrentTime = 1446129611994Enter HelloWorldImpl2.printHelloWorld()CurrentTime = 1446129611994CurrentTime = 1446129611994Enter HelloWorldImpl2.doPrint()CurrentTime = 1446129611994 看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间 基于Spring的AOP使用其他细节 1、增加一个横切关注点，打印日志，Java类为： 123456789101112public class LogHandler&#123; public void LogBefore() &#123; System.out.println("Log before method"); &#125; public void LogAfter() &#123; System.out.println("Log after method"); &#125;&#125; 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean id="helloWorldImpl1" class="com.xrq.aop.HelloWorldImpl1" /&gt; &lt;bean id="helloWorldImpl2" class="com.xrq.aop.HelloWorldImpl2" /&gt; &lt;bean id="timeHandler" class="com.xrq.aop.TimeHandler" /&gt; &lt;bean id="logHandler" class="com.xrq.aop.LogHandler" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="time" ref="timeHandler" order="1"&gt; &lt;aop:pointcut id="addTime" expression="execution(* com.xrq.aop.HelloWorld.*(..))" /&gt; &lt;aop:before method="printTime" pointcut-ref="addTime" /&gt; &lt;aop:after method="printTime" pointcut-ref="addTime" /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect id="log" ref="logHandler" order="2"&gt; &lt;aop:pointcut id="printLog" expression="execution(* com.xrq.aop.HelloWorld.*(..))" /&gt; &lt;aop:before method="LogBefore" pointcut-ref="printLog" /&gt; &lt;aop:after method="LogAfter" pointcut-ref="printLog" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试类不变，打印结果为： 1234567891011121314151617181920212223CurrentTime = 1446130273734Log before methodEnter HelloWorldImpl1.printHelloWorld()Log after methodCurrentTime = 1446130273735CurrentTime = 1446130273736Log before methodEnter HelloWorldImpl1.doPrint()Log after methodCurrentTime = 1446130273736CurrentTime = 1446130273736Log before methodEnter HelloWorldImpl2.printHelloWorld()Log after methodCurrentTime = 1446130273736CurrentTime = 1446130273737Log before methodEnter HelloWorldImpl2.doPrint()Log after methodCurrentTime = 1446130273737 要想让logHandler在timeHandler前使用有两个办法： （1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序 （2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序 2、我只想织入接口中的某些方法 修改一下pointcut的expression就好了： 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean id="helloWorldImpl1" class="com.xrq.aop.HelloWorldImpl1" /&gt; &lt;bean id="helloWorldImpl2" class="com.xrq.aop.HelloWorldImpl2" /&gt; &lt;bean id="timeHandler" class="com.xrq.aop.TimeHandler" /&gt; &lt;bean id="logHandler" class="com.xrq.aop.LogHandler" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="time" ref="timeHandler" order="1"&gt; &lt;aop:pointcut id="addTime" expression="execution(* com.xrq.aop.HelloWorld.print*(..))" /&gt; &lt;aop:before method="printTime" pointcut-ref="addTime" /&gt; &lt;aop:after method="printTime" pointcut-ref="addTime" /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect id="log" ref="logHandler" order="2"&gt; &lt;aop:pointcut id="printLog" expression="execution(* com.xrq.aop.HelloWorld.do*(..))" /&gt; &lt;aop:before method="LogBefore" pointcut-ref="printLog" /&gt; &lt;aop:after method="LogAfter" pointcut-ref="printLog" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 表示timeHandler只会织入HelloWorld接口print开头的方法，logHandler只会织入HelloWorld接口do开头的方法 3、强制使用CGLIB生成代理 前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是&lt;aop:config&gt;里面有一个&quot;proxy-target-class&quot;属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo设置---MarkDown]]></title>
    <url>%2F2019%2F06%2F24%2FHexo%E8%AE%BE%E7%BD%AE-MarkDown%2F</url>
    <content type="text"><![CDATA[hexo-renderer-markdown-it 插件 快速配置 简介 hexo-renderer-markdown-it 是一款用于 Markdown 解析和渲染的插件。 用于替换 Hexo 默认自带的 Markdown 渲染器。 提供了更丰富的 Markdown 解析和渲染。 安装 Hexo 主文件目录下： 卸载 Hexo 默认自带的 Markdown 渲染器 1npm un hexo-renderer-marked --save 安装 hexo-renderer-markdown-it 插件 1npm i hexo-renderer-markdown-it --save 配置 Hexo 主配置文件 _config.yml 中添加以下配置内容（官方提供的完整配置）： 123456789101112131415161718192021# Markdown-it configmarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: &apos;“”‘’&apos; plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup anchors: level: 2 collisionSuffix: &apos;v&apos; permalink: true permalinkClass: header-anchor permalinkSymbol: ¶]]></content>
      <categories>
        <category>Hexo主题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub表情]]></title>
    <url>%2F2019%2F06%2F24%2FGitHub%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[😄 欢迎来到我的博客(小白) 🔑 Dream 💗 I am coming 👉 最新emoji大全（来自大佬）：emoji列表 emoji-list emoji表情列表 人物 :bowtie: :bowtie: 😄 :smile: 😆 :laughing: 😊 :blush: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😦 :frowning: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: :neckbeard: :neckbeard: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐ :star: 🌟 :star2: 💫 :dizzy: 💥 :boom: 💥 :collision: 💢 :anger: ❗ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: :metal: :metal: :fu: :fu: 🚶 :walking: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: 💏 :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: :feelsgood: :feelsgood: :finnadie: :finnadie: :goberserk: :goberserk: :godmode: :godmode: :hurtrealbad: :hurtrealbad: :rage1: :rage1: :rage2: :rage2: :rage3: :rage3: :rage4: :rage4: :suspect: :suspect: :trollface: :trollface: 自然 ☀️ :sunny: ☔ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄ :snowman: ⚡ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌔 :moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅ :partly_sunny: :octocat: :octocat: :squirrel: :squirrel: 事物 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄 :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🍳 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: 地点 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵ :boat: ⛵ :sailboat: 🚣 :rowboat: ⚓ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: 符号 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️ :leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: 🈹 :u5272: 🈴 :u5408: 🈺 :u55b6: 🈯 :u6307: 🈷️ :u6708: 🈶 :u6709: 🈵 :u6e80: 🈚 :u7121: 🈸 :u7533: 🈳 :u7a7a: 🈲 :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔ :no_entry: ✳️ :eight_spoked_asterisk: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈ :aries: ♉ :taurus: ♊ :gemini: ♋ :cancer: ♌ :leo: ♍ :virgo: ♎ :libra: ♏ :scorpius: ♐ :sagittarius: ♑ :capricorn: ♒ :aquarius: ♓ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎ :negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠 :diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: :black_square: :black_square: :white_square: :white_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫ :black_circle: ⚪ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: :shipit: :shipit:]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习]]></title>
    <url>%2F2019%2F06%2F24%2Fjs%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JavaScript学习 基础知识点 什么是JavaScript 一种基于对象和事件驱动的、并具有安全性能的脚本语言----基本概念 特点 向HTML页面添加交互行为 脚本语言，语法和Java类似 解释性语言，边执行边解释 组成 ECMAScript(标准 js遵循这个标准) DOM（文档对象模型） BOM（提供内容与浏览器窗口交互） 引入JavaScript的方式 使用&quot;&quot;标签 外部JS文件 1&lt;script src="" type="text/javascript"&gt;&lt;/script&gt; 直接在HTML标签中 1&lt;input name="btn" type="button" value="弹出消息框" onclick="javascript:alert('welcome');"/&gt; JavaScript核心语法 变量 先声明变量再赋值 12var width; var-----用于声明变量的关键字width = 5; width---变量名 判断变量类型 typeof(“属性名”) String对象 charAt(index) indexOf(str,index) substring(index1,index2) split(str) 数组 创建数组 1var name = new Array(size); - 赋值 12345var f = new Array("a","b");var f = new Array(2);f[0] = "c";f[1] = "b"; - 方法 12length 元素数目join 放入一个字符串，通过一个分隔符分割 运算符 与Java相似 逻辑控制语句 与Java相同 常用输入输出 alert(“信息”)------弹出警告框 prompt(&quot;&quot;,&quot;&quot;) BOM模型(浏览器对象模型) 提供了独立于内容的，可以与浏览器窗口进行互动的对象结构 history对象 location对象 DOM（文档对象模型） 类型 DOM core 针对任何结构性文档的操作方法 HTML-DOM CSS-DOM 根据层次关系访问节点 parentNode childNodes firstChild lastChild nextSibling 下一个节点 previousSibling 上一个节点 ·]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后台交互]]></title>
    <url>%2F2019%2F06%2F23%2F%E5%89%8D%E5%90%8E%E5%8F%B0%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[基于Ajax与JQuery的前后台交互 整合Maven+SSM+IDEA 1、先创建Maven工程 2、手动创建main.java main.resource 以及存储配置文件的目录 3、引入pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;dependencies&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--jdbc连接池--&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DAO: MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Servlet web --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;!-- Spring核⼼ --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring DAO层 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、配置Spring，SpringMVC，Mybatis相关文件 Spring配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;!--数据库连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--配置连接池属性--&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;!--c3p0连接池私有属性--&gt; &lt;property name="maxPoolSize" value="$&#123;maxPoolSize&#125;"/&gt; &lt;property name="minPoolSize" value="$&#123;minPoolSize&#125;"/&gt; &lt;property name="autoCommitOnClose" value="false"/&gt; &lt;property name="checkoutTimeout" value="$&#123;checkoutTimeout&#125;"/&gt; &lt;property name="acquireRetryAttempts" value="$&#123;acquireRetryAttempts&#125;"/&gt; &lt;/bean&gt; &lt;!-- Mybatis的工厂 --&gt; &lt;bean id="sqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 核心配置文件的位置 --&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!-- Mapper动态代理开发 扫描 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 基本包 --&gt; &lt;property name="basePackage" value="com.cn.nuc.dao"/&gt; &lt;/bean&gt; &lt;!-- 注解事务 进行事务判断--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 开启注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; Spring-MVC配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.cn"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping="/**" location="/res" /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--前缀--&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;!--后缀--&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; Mybatis配置文件 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 设置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 2. 指定扫描包，会把包内所有的类都设置别名，别名的名称就是类名，大小写不敏感 --&gt; &lt;package name="com.cn.nuc.pojo" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; db.properties 123456789101112jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password=123456#最大连接数maxPoolSize=20#最小连接数minPoolSize=10#连接超时时间checkoutTimeout=60000#失败重连次数acquireRetryAttempts=3 5、实现前后台交互 配置Spring-MVC.xml 1234添加&lt;mvc:resources mapping="/**" location="/res" /&gt;mapping固定写法 location写你的js文件以及img文件或者其他统一在哪个文件夹下 前台写法，博主在这写了两种写法，其中一种注释了 1234567891011121314151617181920212223242526272829&lt;%-- Created by IntelliJ IDEA. User: Dell Date: 2019/6/23 Time: 18:43 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;%--&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;--%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Ajax&lt;/title&gt;&lt;%-- &lt;script type="text/javascript" src="&lt;c:url value="/res/js/jquery-3.2.1.js"/&gt;"&gt;&lt;/script&gt;--%&gt; &lt;script type="text/javascript" src="/res/js/jquery-3.2.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $.post("hello.do",&#123;&#125;,function (data)&#123; console.log("hello World") &#125;,"json") &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode(一)]]></title>
    <url>%2F2019%2F06%2F21%2FLeetCode-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[算法面试 1、只出现一次的数字 2、求众数 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 第一种解法 123456789101112131415161718192021222324252627282930普通的遍历存Map查找class Solution &#123; public int majorityElement(int[] nums) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int num = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(!map.containsKey(nums[i]))&#123; map.put(nums[i],1); &#125; else&#123; num = map.get(nums[i]); num++; map.put(nums[i],num); &#125; &#125; Iterator iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); if ((int) entry.getValue() &gt; nums.length / 2) &#123; num = (int) entry.getKey(); break; &#125; &#125; return num; &#125;&#125; 第二种解法 摩尔投票法 Moore Voting，需要 O(n) 的时间和 O(1) 的空间 12345678910111213141516171819202122class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 1; int res = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == res) &#123; count++; &#125; else &#123; count--; if (count == 0) &#123; res = nums[i]; count++; &#125; &#125; &#125; return res; &#125;&#125; 3、搜索二维矩阵 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 实现代码 12345678910111213141516class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; if(0 == m) return false; int n = matrix[0].length; if(0 == n) return false; for(int i = 0; i &lt; m; i++)&#123; if(matrix[i][0] &lt;= target &amp;&amp; matrix[i][n-1] &gt;= target)&#123; for(int j = 0; j &lt; n; j++)&#123; if(matrix[i][j] == target) return true; &#125; &#125; &#125; return false; &#125;&#125; 好像可以先对角线找到第一个比给的值大的，然后对左下角和右上角进行二分查找也可以 ​ 附上别人代码，可以体会一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if (m == 0) return false; int n = matrix[0].size(); if (n == 0) return false; if (m == 1) return binary_row_search(matrix, 0, n-1, target); if (n == 1) return binary_col_search(matrix, 0, m-1, target); int square = m &lt;= n ? m : n; int i = 0; for (i = 0; i &lt; square - 1; i++) &#123; if (target == matrix[i][i] || target == matrix[i+1][i+1]) return true; else if (target &gt; matrix[i][i] &amp;&amp; target &lt; matrix[i+1][i+1]) break; &#125; for (int row = i+1; row &lt; m; row++) &#123; if (binary_row_search(matrix, row, i, target)) return true; &#125; for (int col = i+1; col &lt; n; col++) &#123; if (binary_col_search(matrix, col, i, target)) return true; &#125; return false; &#125; // 行搜索 bool binary_row_search(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int row, int end, int target) &#123; int start = 0; while (start &lt;= end) &#123; int mid = start + ((end - start) &gt;&gt; 2); // 右移运算优先级小于加法，切记加括号！！！ if (matrix[row][mid] == target) return true; else if (matrix[row][mid] &lt; target) start = mid + 1; else end = mid - 1; &#125; return false; &#125; // 列搜索 bool binary_col_search(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int col, int end, int target) &#123; int start = 0; while (start &lt;= end) &#123; int mid = start + ((end - start) &gt;&gt; 2); if (matrix[mid][col] == target) return true; else if (matrix[mid][col] &lt; target) start = mid + 1; else end = mid - 1; &#125; return false; &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本站]]></title>
    <url>%2F2019%2F06%2F21%2Ftop%2F</url>
    <content type="text"><![CDATA[​ 博主之前是在CSDN与博客园上写博客的。但是慢慢地CSDN上广告突出…博客园也很少用，就自己上网学习，搭hexo博客。 CSDN 博客园]]></content>
      <tags>
        <tag>Info</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3]]></title>
    <url>%2F2019%2F06%2F20%2Fcss3%2F</url>
    <content type="text"><![CDATA[CSS 二、选择器 孟坤工具箱 层次选择器 后代选择器 123body p&#123; background:red;&#125; 子选择器 123body&gt;p&#123; background:pink;&#125; 相邻选择器 123.active+p&#123; backgroung:green;&#125; 通用兄弟选择器(同一层) 123.active~p&#123; background:yellow;&#125; 结构伪类选择器 选择第一个子元素 123ul li:first-child&#123; background:red;&#125; 选择最后一个子元素 123ul li:last-child&#123; background:green;&#125; 选择第n个子元素(父元素) 123p:nth-child(2)&#123; background:yellow;&#125; 选择第n个元素(同级) 123p:nth-of-type(2)&#123; background:blue;&#125; 属性选择器 E[attr]：选择匹配具有属性attr的E元素 a[id=first]：具有id属性且匹配first a[class=“links”]：class=links的会改变 a[class*=“links”]：class中包含links的会改变 a[href^=http]：以http开头元素 a[href$=png]：以png结尾的元素 三、CSS美化页面 font属性 字体属性的顺序：字体风格→字体粗细→字体大小→字体类型 垂直居中 vertical-align：middle、top、bottom 文本阴影 text-shadow : color x-offset y-offset blur-radius; 背景图片大小 background-size 属性值 描述 auto 默认值，使用背景图片保持原样 percentage 当使用百分值时，不是相对于背景的尺寸大小来计算的，而是相对于元素宽度来计算的 cover 整个背景图片放大填充了整个元素 contain 让背景图片保持本身的宽高比例，将背景图片缩放到宽度或者高度正好适应所定义背景的区域 背景线性渐变 1234background: -webkit-linear-gradient(red,yellow,blue); /* Safari 5.1-6.0 */ background: -o-linear-gradient(red,yellow,blue); /* Opera 11.1-12.0 */ background: -moz-linear-gradient(red,yellow,blue); /* Firefox 3.6-15 */ background: linear-gradient(red,yellow,blue); /* 标准语法 */ 盒子模型 要把容器想象成为一个盒子 理解外边距，内边距，边框的含义。 12345box-sizing：content-box | border-box | inherit;1. 默认值，盒子的总尺度2. 盒子的宽度或高度等于元素内容的宽度或高度3. 元素继承父元素的盒子模型模式 盒子阴影 1box-shadow:inset x-offset y-offset blur-radius color; 浮动 overflow（父类使用） 属性值 说明 visible 默认值。内容不会被修剪，会呈现在盒子之外 hidden 内容会被修剪，并且其余内容是不可见的 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余内容 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容 父级添加伪类after 12345.clear:after&#123; content: ''; /*在clear类后面添加内容为空*/ display: block; /*把添加的内容转化为块元素*/ clear: both; /*清除这个元素两边的浮动*/&#125; 定位网页元素 static—没有定位，以标准流方式显示 relativ—相对自身原来位置进行偏移 偏移设置：top、left、right、bottom absolute—相对于父类 偏移设置： left、right、top、bottom fixed—固定位置 CSS变形 transform:[transform-function] *; translate()：平移函数，基于X、Y坐标重新定位元素的位置 scale()：缩放函数，可以使任意元素对象尺寸发生变化 rotate()：旋转函数，取值是一个度数值 skew()：倾斜函数，取值是一个度数值 过渡 transition:[transition-property transition-duration transition-timing-function transition-delay ] 过渡动画函数 12345ease：速度由快到慢（默认值）linear：速度恒速（匀速运动）ease-in：速度越来越快（渐显效果）ease-out：速度越来越慢（渐隐效果）ease-in-out：速度先加速再减速（渐显渐隐效果） 动画 12345678910111213141516171819202122232425@keyframes spread &#123; 0% &#123;width:0;&#125; 33% &#123;width:23px;&#125; 66% &#123;width:46px;&#125; 100% &#123;width:69px;&#125; &#125; ## 使用 animation:animation-name animation–duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state animation-fill-mode;动画的播放次数（animation-iteration-count） 值通常为整数，默认值为1 特殊值infinite，表示动画无限次播放动画的播放方向（animation-direction） normal，动画每次都是循环向前播放 alternate，动画播放为偶数次则向前播放动画的播放状态（animation-play-state） running将暂停的动画重新播放 paused将正在播放的元素动画停下来动画发生的操作（animation-fill-mode） forwards表示动画在结束后继续应用最后关键帧的位置 backwards表示会在向元素应用动画样式时迅速应用动画的初始帧 both表示元素动画同时具有forwards和backwards的效果]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出-MySQL]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-MySQL%2F</url>
    <content type="text"><![CDATA[一、SQL基础 1、SQL分类 DDL：数据定义语句 创建数据库 123456create database test1## 数据库中已有的1. information_schema:存储系统中的一些数据库对象信息2. cluster:存储了系统的集群信息3. mysql: 存储了系统的用户权限信息。4. test: 系统自动创建的测试数据库。 删除数据库 1drop database test1 创建表 12345678create table **();查看表的定义DESC **查看创建表的SQL语句show create table ** \G;在这里我们可以看到ENGINE（存储引擎）和CHARSET（字符集信息） 删除表 1drop table emp 修改表 12345678910111213141516171819## 修改表类型alter table emp modify ename varchar(20)## 增加表字段alter table emp add column age int(3)## 删除表字段alter table emp drop column age;## 字段改名alter table emp change age age1 int(4);## 修改字段排列顺序(可选项 first|after)alter table emp add birth data after ename; &gt; 修改字段age，将它放在最前边 alter table emp modify age int(3) first;## 更改表名alter table emp rename emp1; DML：数据操作语句 ​ 是对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询。 插入记录 12345## 插入语句insert into emp(1,2) values(1,2)## 一次性插入多条语句insert into emp(1,2) values(1,2),(2,3) 更新记录 1234## 更新update emp set 1=1 wherh ename='lisi'## 同时更新两个表与这个情况类似 删除记录 12## 删除delete from emp where ename='dony' 查询记录 12345678910111213141516171819202122232425262728293031323334353637383940## 查询select * from emp## 查询不重复的记录select distinct deptno from emp;## 条件查询(=、&gt;、&lt;、&gt;=、&lt;=、!=)select * from emp where 1=1 and 2=2;## 排序和限制select * from emp order by sal;desc----&gt;降序 asc------&gt;升序## 分页查询select * from emp order by sal limit 1,3 -----&gt;第一个参数为起始偏移量，第二个为行数## 聚合select [f1,f2,f3...]fun_name------&gt;聚合函数 sun，count，max，minfrom tablename[WHERE where_contition] -----&gt;条年间查询[GROUP BY field1,field2 -----&gt;分类聚合字段[WITH ROLLUP]] -----&gt;表名是否对分类聚合进行汇总[HAVING where_contition]-----&gt;对分类后的结果再进行条件的过滤## 连接1、内连接 仅选出两张表中互相匹配的记录 fx：查询所有雇员的名字和所在的部门名称 select ename,deptname from emp,dept where emp.deptno=dept.deptno;2、外连接 左连接：包含所有左边表中的记录甚至是右边表中没有和它匹配的记录。 右连接：包含所有右边表中的记录甚至是左边表中没有和它匹配的记录。3、子查询（条件是另一select语句的结果） select * fomr emp where 1 in(select 1 from dept); 如果查询条件唯一，可以使用=代替in4、记录联合 UNION: 将UNION ALL后的结果进行一次DISTINCT UNION ALL 把结果集直接合并在一起 DCL：数据控制语句-----管理系统中的对象权限时使用 2、MySQL数据类型 整数类型 字节 最小值 最大值 TINYINT 1 有符号-128无符号 0 有符号 127无符号 255 SMALLINT 2 有符号-32768无符号 0 有符号32767无符号 65535 MEDIUMINT 3 有符号-8388608无符号 0 有符号8388607无符号 1677215 INT,INTEGER 4 有符号-2147483648无符号 0 有符号2147483647无符号 4294967295 BIGINT 8 有符号-9223372036854775808无符号 0 有符号9223372036854775807无符号 18446744073709551615 浮点数类型 字节 最小值 最大值 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 位类型 字节 最小值 最大值 BIT 1~8 BIT(1) BIT(64) 二、MySQL开发篇 1、表类型的选择]]></content>
      <categories>
        <category>MySQL学习</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解]]></title>
    <url>%2F2019%2F06%2F19%2FSpring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[核心容器 Spring的核心jar包 ​ 一、spring-context-----maven注入 没有注解之前，使用配置方式 ​ 使用注解 @Configuration 配置类 @Bean给容器一注册一个Bean；类型为方绘制的类型，id默认为id 可以给Bean添加value值 12ApplicationContextnew a = AnnotationConfigApplicationContext(配置类.class);Person p = a.getBean(Person.class); 包扫描&lt;context:componet-scan class=&quot;&quot;&gt;&lt;/context:componet-scan&gt; 只要标注了@Controller @Service @Repository @Component 自动扫描 包扫描过滤 在其下边继续写&lt;context:include合作者exclude 另一种方法可以在配置类上边加注解 @ComponentScan(value=&quot;&quot;)----和上边包扫描效果一样会自动扫描 12345指定要扫描的包@ComponentScan(value="",excludeFilters = &#123; @Filter(type=FilterType.ANNOTATION,classes= &#123;Controller.class,Service,class&#125;) &#125;)如果要使用只扫描--我们需要把useDefaultFilters = false 默认扫描关闭 在其中我们还可以使用ComponentScans来扫描多个 value是数组 常用规则（扫描方式） FilterType.* 1、ANNOTATION 按照注解 2、ASSIGNABLE_TYPE 按照给定的类型 3、ASPECTJ ASPECTJ表达式 4、REGEX 正则表达式 5、CUSTOM 自定义规则 需要实现TypeFilter接口 修改Scope（调整组件作用域） prototype 多实例的 singletion 单实例的 懒加载@Lazy 单实例Bean：默认在启动的时候创建对象 第一次使用Bean的时候再创建对象-----懒加载 按照条件注册bean @Conditional: 按照一定的条件进行判断，满足条件给容器中注册bean @Conditional(Condition数组—》类.class) 实现的类需要实现Conditional接口，来为后续的判断提供条件 import[快速给容器导入组件] @Import(要导入到容器中的组件)；容器就会自动注册这个组件 @ImportSelector：返回需要导入的组件的全类名的注解 实现的接口 里边写返回的类函数 @ImportBeanDefinitionRegistrar 手动注册bean到容器中 使用Spring的FactoryBean方法（工厂Bean） 获得工厂bean的方法 在前边加引用 Bean的生命周期 自定义初始化和销毁方法 指定初始化和销毁方法 指定init-method 和 destory-method方法（配置文件时候使用的方法） @Bean(initMethod=&quot;&quot;,destoryMethod=&quot;&quot;) ------ 注解的情况 初始化：对象创建完成，并赋值好，调用初始化方法 销毁：容器关闭之后调用 多实例不进行销毁 通过实现InitializingBean接口(初始化)，DisposableBean接口(销毁) 在实现一个类之后，可以把它定义为组件@Compotent 这样是可以被配置文件进行扫描的 可以使用JSR250 @PostConstruct:在Bean 创建完成，并且属性赋值完成，执行初始化 @PreDestory: 在容器销毁Bean之前通知我们进行清理工作 BeanPostProcessor:bean的后置处理器（在Spring后端也大量使用） 在bean初始化前后进行工作 postProcessBeforeInitialization：初始化之前 postProcessAfterInitialization：在初始化之后 Spring底层对BeanPostProcessor的使用 bean赋值，注入其他主键，@Autowired，生命周期注解功能]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础]]></title>
    <url>%2F2019%2F06%2F18%2FJavaSE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaSE面试要点以及知识概要 1、面向对象的特征有哪些方面 抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 2、基本数据类型 ​ 基本数据类型包括 byte、int、char、long、float、double、boolean、short ​ java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 3、super和this的区别 ​ super代表父类对象，this代表当前类对象 ​ super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。 4、==和equals的区别 == 基本类型：比较值是否相同 引用类型：比较引用是否相同 代码示例 1234567String x = "string";String y = "string";String z = new String("string");system.out.println(x==y); //true 比较引用system.out.println(x==z); //false 比较引用system.out.println(x.equals(y)); //true 比较值system.out.println(x.equals(z)); //true 比较值 equals ​ equals本质上是==，不过String和Integer等重写了equals方法，变为了值比较 5、两个对象的hashcode相同，equals相同么 ​ hashcode得到的是哈希值相同，然而哈希值相同，并不能得到键值对相同。 6、final在Java中的作用 final修饰的类交最终类，改类不能被继承 final修饰的方法不能被重写 final修饰的变量交常量，常量必须初始化，初始化之后值不能被修改 7、操作字符串的类 String声明的是不可变的对象，每次操作都会生成新的String对象。 StringBuffer、StringBuilder可以在原有对象的基础上进行操作 String和StringBuilder的区别 1. StringBuffer是线程安全的 StringBuilder是非线程安全的 2.StringBuilder性能比StringBuffer高 3.单线程可以使用StringBulider 多项成使用StringBuffer 8、String s=“i” 与 String s1=new String(“asd”)的区别 ​ 第一种是分配到常量池中，第二种是分配到堆内存中。 9、抽象类必须要有抽象方法么？ ​ 不需要，抽象类不一定非要有抽象方法。 我们来具体分析一下抽象与接口 抽象类是什么？（抽象类只能作为父类被继承，避免子类的随意性） 抽象方法只做声明，而不包含实现，可以看成是没有实现体的虚方法 抽象类不能被实例化 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类 具体派生类必须覆盖基类的抽象方法 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们 接口是什么？ 接口不能被实例化 接口只能包含方法声明 接口的成员包括方法、属性、索引器、事件 接口中不能包含常量、字段(域)、构造函数、析构函数(Java存在自动回收机制，一般用不到析构函数)、静态成员 接口和抽象类的区别 重要 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含静态方法，接口中不能包含静态方法 一个类可以实现多个接口，但只能继承一个抽象类。 接口可以被多重实现，抽象类只能被单一继承 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法 接口和抽象类的相同点 都可以被继承 都不能被实例化 都可以包含方法声明 派生类必须实现未实现的方法 10、&amp;和&amp;&amp;的区别？ &amp;运算符有两种用法： - 按位与； - 逻辑与。 - &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(&quot;&quot;)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。 11、关键字 与流程控制相关的 关键字 知识点 if 表示条件判断，一般用法if（关系表达式），后跟else或{……} esle 条件转折，如if （关系表达式）{语句块1}else{语句块2}，如果关系表达式的值为true，则执行语句块1，否则执行语句块2. do……while…… do和while一般一起使用，用于表示循环语句。do{……}while（关系表达式）……；当关系表达式的值为true是继续循环。 for 用于表示循环，for循环是最常使用的循环，格式for（表达式a; 表达式b; 表达式c）括号里面的书通常用于控制循环的次数，一般会用一个int类型的变量类计数，如（int i=0; i&lt;10; i++）表达式a用于流程控制的开始值，表达式b表示循环终止条件，表达式c用于计数。 switch 分支语句 default 条件不成立 break 跳出 continue 跳出本次循环 return 返回值 try……catch……finally…… 异常处理 与修饰符有关的 范围 本类 同软件包 不同包中子类 不同包且无继承 作用(含义) public 可以 可以 可以 可以 公有的 protect 可以 可以 可以 受保护的 default(无权限修饰符) 可以 可以 当前的 private 可以 私有的 关键字 知识点 final 1. final的变量的值不能被改变 a.final的成员变量 b.final的局部变量；2. final的方法不能被重写；3. final的类不能被继承。 Synchronized 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。 Lock synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 12、Java中的覆盖与重载的含义 1. 覆盖是发生在同一个类里边或者多个方法的方法名相同但参数不用的情况。 2. 方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 13、面向对象的&quot;六原则一法则&quot;。 名称 作用 单一职责原则（高内聚） 一个类只做它该做的事情 开闭原则 软件实体应当对扩展开放，对修改关闭。 依赖倒转原则 面向接口编程。 里氏替换原则 任何时候都可以用子类型替换掉父类型 接口隔离性 接口要小而专，绝不能大而全。 合成聚合复用原则 优先使用聚合或合成关系复用代码。 迪米特法则（低耦合） 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。 14、🔑:static关键字—重点 1、static关键字的用途 “static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” —Java编程思想 方便在没有创建对象的情况下来进行调用（方法/变量）。 1.1、static方法 ​ static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 1.2static变量 ​ static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 ​ static成员变量的初始化顺序按照定义的顺序进行初始化。 1.3static代码块 ​ 优点： ​ 1、可以使用static来优化程序性能。-------类加载的时候只执行一次 2、static的误区 2.1static关键字会改变类中成员的访问权限吗？ ​ 答案是：不会的，影响Java的只有private、public、protected（包活访问权限）这几个关键字。 2.2能通过this访问静态成员变量吗？ ​ 可以的 1234567891011121314public class Main &#123; static int value = 33; public static void main(String[] args) &#123; new Main().printValue(); &#125; private void printValue()&#123; int value = 3; System.out.println(this.value); &#125;&#125;//输出33 2.3static不允许修饰局部变量 3、问答题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test &#123; Person person = new Person("Test"); static &#123; System.out.println("test static"); &#125; public Test()&#123; System.out.println("test constructor"); &#125; public static void main(String[] args) &#123; new Myclass(); &#125;&#125;class Person&#123; static &#123; System.out.println("person static"); &#125; public Person(String str)&#123; System.out.println("person:"+str); &#125;&#125;class Myclass extends Test&#123; Person person = new Person("MyClass"); static &#123; System.out.println("myclass static"); &#125; public Myclass()&#123; System.out.println("myclass constructor"); &#125;&#125;//上述代码输出结果/*test staticmyclass staticperson staticperson:Testtest constructorperson:MyClassmyclass constructor*/]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实训---html]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%AE%9E%E8%AE%AD-html%2F</url>
    <content type="text"><![CDATA[HTML W3C标准 1. 结构化标准语言(HTML,XHML) 2. 表现标准语言(CSS) 3. 行为标准(DOM) meta设置 1234567891011121314151617181920&lt;meta charset="UTF-8"&gt;&lt;title&gt;我的第一个网页&lt;/title&gt;&lt;!--设置过期--&gt;&lt;meta http-equiv="Expires" content="0"&gt;&lt;!--跳转页面--&gt;&lt;meta http-equiv="refresh" content="2:http://www.baidu.com"&gt;&lt;!----&gt;&lt;meta http-equiv="Pragma" content="No-cach"&gt;&lt;!--无法被其他网页嵌套--&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!--网页特效--&gt;&lt;meta http-equiv="Page-Exit"&gt;&lt;!--搜索关键字--&gt;&lt;meta name="Keywords" lang="EN" content="中北大学"&gt;&lt;!--设置网页简介--&gt;&lt;meta name="description" content="中北大学"&gt;&lt;!--设置网址作者--&gt;&lt;meta name="Author" content="银尘"&gt;&lt;!--设置网站的版本--&gt;&lt;meta name="Copyright" content="本页版权归银尘所有"&gt; 页面布局分析 H5结构元素 方法名 作用位置 header 头部 nav 头部 aside 侧面栏 section 主题部分 article 主题部分 footer 尾部 框架 frameset----现在不经常使用了 iframe—基本都使用这个（灵活）]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java容器知识点]]></title>
    <url>%2F2019%2F06%2F18%2FJava%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Java容器与设计模式解释 单例模式 静态初始化（饿汉式） 双重检查（懒汉式） 用到的时候才会建立，不用则不会建立 要考虑多个线程的并发问题 通过lock和synchronized双重检查 保证只有一个线程运行 内存可见性 volatile 修饰 单例注册表 常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 反射 静态代理:编译时创建好的 源代码中编写的类 动态代理:在JVM 责任链模式：Netty消息处理的方式 适配器模式：SLF4J如何支持Log4J — 接口 观察者模式（一个对象的某个事件触发某些行为）：GRPC是如何支持流式请求的 构造者模式（多个复杂的属性）：PB序列化中的Builder Java语言特性 知识详解 ==HashMap== 数组加链表的实现方式 容量大小是2的幂次方 可以利用按位与操作，计算余数 并发读写的风险（参考源码） 死循环问题 HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） 工作原理 HashMap 在 Map.Entry 静态内部类实现中存储键值对，使用哈希算法。在 put 和 get 方法中，使用 hashCode() 和 equals() 方法。 调用 put 方法时，使用键值对中的 Key hashCode() 和哈希算法找出存储键值对索引。键值对 Entry 存储在 LinkedList 中，如果存在 Entry，使用 equals() 方法来检查 Key 是否已经存在：如果存在，则覆盖 value；如果不存在，会创建一个新的 Entry 然后保存。 调用 get 方法时，HashMap 使用键值 Key hashCode() 来找到数组中的索引，然后使用 equals() 方法找出正确的 Entry，返回 Entry 中的 Value。 ==ConcurrentHashMap== ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 并发控制与分段锁的思想 1.8的CAS自旋锁 红黑树的启动条件 TREEIFY THRESHOLD==8 阈值超过8 小于6就转回链表 具体的get方法 - 当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。 hash源码 1234567891011static final int hash(Object key) &#123; if (key == null)&#123; return 0; &#125; int h; h = key.hashCode()；返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 //其中n是数组的长度，即Map的数组部分初始化长度 return (n-1)&amp;(h ^ (h &gt;&gt;&gt; 16)); &#125; 源码分析(个人理解n初始化数组长度为16) 高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）(n·1) &amp; hash = -&gt; 得到下标 为什么一直使用红黑树，不使用二叉树呢? 二叉树在使用过程中可能会变成一条线性结构，这就相当于链表结构了，查找速度会很慢。红黑树可以在插入数据时进行左旋，右旋、变色这些操作来保持平衡。所以，我们在长度大于8的时候，我们会使用红黑树，长度小于8的时候就没有必要用了，反而会更慢。 说说你对红黑树的见解 应该不会手撕。。。。 每个节点非红即黑 根节点总是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 每个叶子节点都是黑色的空节点（NIL节点） 5.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 解决hash碰撞的方法 开放定址法 当冲突发生时，使用某种探查技术在散列表中形成一个探查（测）序列。沿此序列逐个单元地查找，直到找到给定的地址。按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。 如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？ HashMap 默认的负载因子大小为0.75。也就是说，当一个 Map 填满了75%的 bucket 时候，和其它集合类一样（如 ArrayList 等），将会创建原来 HashMap 大小的两倍的 bucket 数组来重新调整 Map 大小，并将原来的对象放入新的 bucket 数组中。这个过程叫作 rehashing。只有两个可能的位置:一个是原下标的位置，另一种是在下标为 &lt;原下标+原容量&gt; 的位置。 什么情况会引起多线程 在调整HashMap大小的时候，如果两个线程同时调整HashMap大小的话，可能会发生条件竞争。然后就----&gt;死循环了。。。 为什么多线程会死循环。怎么发生的？ HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。这时候， HashMap 需要扩展它的长度，也就是进行Resize。 扩容：创建一个新的 Entry 空数组，长度是原数组的2倍rehash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 详解 HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 容器的区别 ==HashTable与HashTable== HashTable 数组+链式存储 默认容量：11 put操作：首先进行索引计算 （key.hashCode() &amp; 0x7FFFFFFF）% table.length；若在链表中找到了，则替换旧值，若未找到则继续；当总元素个数超过 容量 * 加载因子 时，扩容为原来 2 倍并重新散列；将新元素加到链表头部 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全 HashMap和HashTable的区别 默认容量不同，扩容不同 线程安全性： HashTable安全 效率不同： HashTable要慢 加锁了 可以使用 CocurrentHashMap 来代替 Hashtable 吗？ 我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁 ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性 它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map ==Collection详解== 1.Set TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序 2.List ArrayList 基于动态数组实现，支持随机访问。 Vector 和 ArrayList 类似，但它是线程安全的。 LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 3.Queue LinkedList 可以用来实现双向队列 PriorityQueue 基于堆结构实现，可以用它来实现优先队列。 4.Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 5. ArrayList和Vector的区别 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; synList = Collections.synchronizedList(list); 6.ArrayList和LinkedList比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 7.LinkedHashMap 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 8.为什么要实现序列化 实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果 你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布 式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式]]></title>
    <url>%2F2019%2F05%2F25%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 反射 静态代理:编译时创建好的 源代码中编写的类 动态代理:在JVM 责任链模式：Netty消息处理的方式 适配器模式：SLF4J如何支持Log4J — 接口 观察者模式（一个对象的某个事件触发某些行为）：GRPC是如何支持流式请求的 构造者模式（多个复杂的属性）：PB序列化中的Builder 一、单例模式 需要考虑的三点因素 线程安全 延迟加载 序列化与反序列化安全 二、设计模式的六大原则 名称 作用 单一职责原则（高内聚） 一个类只做它该做的事情 开闭原则 软件实体应当对扩展开放，对修改关闭。 依赖倒转原则 面向接口编程。 里氏替换原则 任何时候都可以用子类型替换掉父类型 接口隔离性 接口要小而专，绝不能大而全。 合成聚合复用原则 优先使用聚合或合成关系复用代码。 迪米特法则（低耦合） 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。 三、常用模式讲解 1、工厂方法模式 1.1普通工厂模式：建立一个工厂类，对实现了同一接口的一些类进行实例的创建 12345首先，创建二者的共同接口：public interface Sender &#123; public void Send();&#125; 12345678910111213141516其次，创建实现类：public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125;&#125; 1.2多工厂模式 是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 123456789101112public class SendFactory &#123; //将以前的字符串匹配改为直接创建实例 public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125;&#125; 1.3静态工厂模式：将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 12345678910public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125;&#125; 2、抽象工厂模式 2.1为什么不用工厂模式？ ​ 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 2.2详细解释 简单来说：创建一个工厂接口，并且书写类来实现接口，能够在由需求的情况下，在书写一个类，并实现接口。 fx： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//接口public interface Sender &#123; public void Send();&#125;//实现类public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125;&#125;public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125;&#125;//工厂接口public interface Provider &#123; public Sender produce();&#125;//工厂类public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125;&#125;public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125;&#125; 3、单例模式 单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 3.1单例模式的好处 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 单例类 12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125;&#125; ​ 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下： 123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; ​ 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个： 12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 4、建造者模式 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。 12345678910111213141516171819202122232425public class Builder &#123; private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new MailSender()); &#125; &#125; public void produceSmsSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new SmsSender()); &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; Builder builder = new Builder(); builder.produceMailSender(10); &#125;&#125; ​ 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。 5、原型模式 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类： 6、适配器模式 6.1应用场景 6.1.1类的适配器模式： 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 6.1.2对象的适配器模式： 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 6.1.3接口的适配器模式： 当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。` 7、代理模式 7.1概念 ​ 其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法 7.2应用场景 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 8、策略模式 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 9、观察者模式 包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//一个Observer接口：public interface Observer &#123; public void update();&#125;//两个实现类：public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println("observer1 has received!"); &#125;&#125;public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println("observer2 has received!"); &#125; &#125;//Subject接口及实现类：public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation();&#125;public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125;&#125;public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println("update self!"); notifyObservers(); &#125; &#125;//测试类public class ObserverTest &#123; public static void main(String[] args) &#123; Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); &#125; &#125;]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
