<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java容器知识点]]></title>
    <url>%2F2019%2F06%2F18%2FJava%E5%AE%B9%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[单例模式 静态初始化（饿汉式）双重检查（懒汉式） 用到的时候才会建立，不用则不会建立 要考虑多个线程的并发问题 通过lock和synchronized双重检查 保证只有一个线程运行 内存可见性 volatile 修饰 单例注册表常用设计模式与应用场景 工厂模式：Spring如何创建Bean 代理模式：Motan服务的动态代理 反射 静态代理:编译时创建好的 源代码中编写的类 动态代理:在JVM 责任链模式：Netty消息处理的方式 适配器模式：SLF4J如何支持Log4J — 接口 观察者模式（一个对象的某个事件触发某些行为）：GRPC是如何支持流式请求的 构造者模式（多个复杂的属性）：PB序列化中的Builder Java语言特性知识详解==HashMap== 数组加链表的实现方式 容量大小是2的幂次方 可以利用按位与操作，计算余数 并发读写的风险（参考源码） 死循环问题 HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射 HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改 HashMap 是非 synchronized，所以 HashMap 很快 HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以） 工作原理 HashMap 在 Map.Entry 静态内部类实现中存储键值对，使用哈希算法。在 put 和 get 方法中，使用 hashCode() 和 equals() 方法。 调用 put 方法时，使用键值对中的 Key hashCode() 和哈希算法找出存储键值对索引。键值对 Entry 存储在 LinkedList 中，如果存在 Entry，使用 equals() 方法来检查 Key 是否已经存在：如果存在，则覆盖 value；如果不存在，会创建一个新的 Entry 然后保存。 调用 get 方法时，HashMap 使用键值 Key hashCode() 来找到数组中的索引，然后使用 equals() 方法找出正确的 Entry，返回 Entry 中的 Value。 ==ConcurrentHashMap== ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 并发控制与分段锁的思想 1.8的CAS自旋锁 红黑树的启动条件 TREEIFY THRESHOLD==8 阈值超过8 小于6就转回链表 具体的get方法 - 当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。 hash源码 1234567891011static final int hash(Object key) &#123; if (key == null)&#123; return 0; &#125; int h; h = key.hashCode()；返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 //其中n是数组的长度，即Map的数组部分初始化长度 return (n-1)&amp;(h ^ (h &gt;&gt;&gt; 16)); &#125; 源码分析(个人理解n初始化数组长度为16) 高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）(n·1) &amp; hash = -&gt; 得到下标 为什么一直使用红黑树，不使用二叉树呢? 二叉树在使用过程中可能会变成一条线性结构，这就相当于链表结构了，查找速度会很慢。红黑树可以在插入数据时进行左旋，右旋、变色这些操作来保持平衡。所以，我们在长度大于8的时候，我们会使用红黑树，长度小于8的时候就没有必要用了，反而会更慢。 说说你对红黑树的见解 应该不会手撕。。。。 每个节点非红即黑 根节点总是黑色的 如果节点是红色的，则它的子节点必须是黑色的（反之不一定） 每个叶子节点都是黑色的空节点（NIL节点） 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 解决hash碰撞的方法 开放定址法 当冲突发生时，使用某种探查技术在散列表中形成一个探查（测）序列。沿此序列逐个单元地查找，直到找到给定的地址。按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。 如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？ HashMap 默认的负载因子大小为0.75。也就是说，当一个 Map 填满了75%的 bucket 时候，和其它集合类一样（如 ArrayList 等），将会创建原来 HashMap 大小的两倍的 bucket 数组来重新调整 Map 大小，并将原来的对象放入新的 bucket 数组中。这个过程叫作 rehashing。只有两个可能的位置:一个是原下标的位置，另一种是在下标为 &lt;原下标+原容量&gt; 的位置。 什么情况会引起多线程 在调整HashMap大小的时候，如果两个线程同时调整HashMap大小的话，可能会发生条件竞争。然后就—-&gt;死循环了。。。 为什么多线程会死循环。怎么发生的？ HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。这时候， HashMap 需要扩展它的长度，也就是进行Resize。扩容：创建一个新的 Entry 空数组，长度是原数组的2倍rehash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 详解 HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 容器的区别==HashTable与HashTable== HashTable 数组+链式存储 默认容量：11 put操作：首先进行索引计算 （key.hashCode() &amp; 0x7FFFFFFF）% table.length；若在链表中找到了，则替换旧值，若未找到则继续；当总元素个数超过 容量 * 加载因子 时，扩容为原来 2 倍并重新散列；将新元素加到链表头部 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全 HashMap和HashTable的区别 默认容量不同，扩容不同 线程安全性： HashTable安全 效率不同： HashTable要慢 加锁了 可以使用 CocurrentHashMap 来代替 Hashtable 吗？ 我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁 ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性 它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map ==Collection详解== Set TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序 List ArrayList 基于动态数组实现，支持随机访问。 Vector 和 ArrayList 类似，但它是线程安全的。 LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList 可以用来实现双向队列 PriorityQueue 基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 5. ArrayList和Vector的区别Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List&lt;String&gt; synList = Collections.synchronizedList(list);6.ArrayList和LinkedList比较ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。7.LinkedHashMap继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 8.为什么要实现序列化实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果 你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布 式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
